name: Update Team BaerCraft download counts

permissions:
  contents: write

on:
  schedule:
    # Every hour at minute 5 â€” change if you want
    - cron: "5 * * * *"
  workflow_dispatch: {}

jobs:
  update-downloads:
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Fetch download counts and logos
        run: |
          node << 'EOF'
          const https = require('https');
          const fs = require('fs');

          // Your projects
          const PROJECTS = [
            {
              id: 990265,
              slug: 'plushie-buddies',
              name: 'Plushie Buddies',
              type: 'Mod',
              curseforgeUrl: 'https://www.curseforge.com/minecraft/mc-mods/plushie-buddies'
            },
            {
              id: 586179,
              slug: 'trash-panda-craft',
              name: 'Trash Panda Craft',
              type: 'Modpack',
              curseforgeUrl: 'https://www.curseforge.com/minecraft/modpacks/trash-panda-craft'
            },
            {
              id: 1250043,
              slug: 'rpg-bosses',
              name: 'RPG Bosses',
              type: 'Mod',
              curseforgeUrl: 'https://www.curseforge.com/minecraft/mc-mods/rpg-bosses'
            },
            {
              id: 1038674,
              slug: 'cultivators-edge',
              name: "Cultivator's Edge",
              type: 'Mod',
              curseforgeUrl: 'https://www.curseforge.com/minecraft/mc-mods/cultivators-edge'
            },
            {
              id: 872923,
              slug: 'pokeasub',
              name: 'PokeASub',
              type: 'Modpack',
              curseforgeUrl: 'https://www.curseforge.com/minecraft/modpacks/pokeasub'
            },
            {
              id: 1022947,
              slug: 'hammer-havoc',
              name: 'Hammer Havoc',
              type: 'Mod',
              curseforgeUrl: 'https://www.curseforge.com/minecraft/mc-mods/hammer-havoc'
            },
            {
              id: 458165,
              slug: 'baercraft',
              name: 'BaerCraft',
              type: 'Modpack',
              curseforgeUrl: 'https://www.curseforge.com/minecraft/modpacks/baercraft'
            },
            {
              id: 462963,
              slug: 'baers-additions',
              name: "Baer's Additions",
              type: 'Mod',
              curseforgeUrl: 'https://www.curseforge.com/minecraft/mc-mods/baers-additions'
            },
            {
              id: 643632,
              slug: 'baers-renditions',
              name: "Baer's Renditions",
              type: 'Resource Pack',
              curseforgeUrl: 'https://www.curseforge.com/minecraft/texture-packs/baers-renditions'
            },
            {
              id: 925715,
              slug: 'create-reclaimed-rocks',
              name: 'Create: Reclaimed Rocks',
              type: 'Mod',
              curseforgeUrl: 'https://www.curseforge.com/minecraft/mc-mods/create-reclaimed-rocks'
            }
          ];

          const MAX_HISTORY = 500;

          function fetchJson(url) {
            return new Promise((resolve, reject) => {
              https
                .get(url, (res) => {
                  let body = '';
                  res.on('data', (chunk) => (body += chunk));
                  res.on('end', () => {
                    if (res.statusCode !== 200) {
                      return reject(
                        new Error(`${url} returned ${res.statusCode}: ${body}`)
                      );
                    }
                    try {
                      const json = JSON.parse(body);
                      resolve(json);
                    } catch (e) {
                      reject(new Error(`Failed to parse JSON from ${url}: ${e.message}`));
                    }
                  });
                })
                .on('error', (err) => reject(err));
            });
          }

          function fetchPage(url) {
            return new Promise((resolve, reject) => {
              https
                .get(
                  url,
                  {
                    headers: {
                      'User-Agent': 'TeamBaerCraft-GitHubActions/1.0'
                    }
                  },
                  (res) => {
                    let body = '';
                    res.on('data', (chunk) => (body += chunk));
                    res.on('end', () => {
                      if (res.statusCode !== 200) {
                        return reject(
                          new Error(`CurseForge page ${url} returned ${res.statusCode}`)
                        );
                      }
                      resolve(body);
                    });
                  }
                )
                .on('error', (err) => reject(err));
            });
          }

          function parseDownloadMessage(msg) {
            if (typeof msg !== 'string') return null;
            const trimmed = msg.trim().toLowerCase();

            const match = trimmed.match(/^([\d.,]+)\s*([kmb])?$/i);
            if (!match) {
              const numeric = parseInt(trimmed.replace(/[^0-9]/g, ''), 10);
              return Number.isFinite(numeric) ? numeric : null;
            }

            let num = parseFloat(match[1].replace(',', ''));
            if (!Number.isFinite(num)) return null;
            const suffix = match[2];
            if (suffix === 'k') num *= 1_000;
            else if (suffix === 'm') num *= 1_000_000;
            else if (suffix === 'b') num *= 1_000_000_000;
            return Math.round(num);
          }

          function extractLogoUrl(html) {
            if (typeof html !== 'string') return null;

            // 1) Try og:image meta tag first
            const ogMatch = html.match(
              /<meta[^>]+property=["']og:image["'][^>]+content=["']([^"']+)["']/i
            );
            if (ogMatch && ogMatch[1]) {
              return ogMatch[1];
            }

            // 2) Fallback: any media.forgecdn.net avatars URL
            const avatarMatch = html.match(
              /https?:\/\/media\.forgecdn\.net\/avatars\/[^\s"']+/i
            );
            if (avatarMatch && avatarMatch[0]) {
              return avatarMatch[0];
            }

            // 3) Last resort: any media.forgecdn.net image
            const anyImgMatch = html.match(
              /https?:\/\/media\.forgecdn\.net\/[^\s"']+\.(?:png|jpe?g|gif)/i
            );
            if (anyImgMatch && anyImgMatch[0]) {
              return anyImgMatch[0];
            }

            return null;
          }

          // Load existing data
          let existing = { lastUpdated: null, projects: [] };
          try {
            const raw = fs.readFileSync('download-data.json', 'utf8');
            const parsed = JSON.parse(raw);
            if (parsed && typeof parsed === 'object') {
              existing = parsed;
              if (!Array.isArray(existing.projects)) {
                existing.projects = [];
              }
            }
          } catch (_e) {
            // file may not exist yet, that's fine
          }

          const existingById = new Map();
          for (const p of existing.projects) {
            if (p && typeof p.id === 'number') {
              existingById.set(p.id, p);
              if (!Array.isArray(p.history)) p.history = [];
            }
          }

          const now = new Date().toISOString();

          (async () => {
            const updatedProjects = [];

            for (const proj of PROJECTS) {
              console.log(`Fetching stats for ${proj.name} (${proj.id})`);

              // 1) Downloads from Shields.io
              const badge = await fetchJson(
                `https://img.shields.io/curseforge/dt/${proj.id}.json`
              );
              const message = badge && badge.message;
              const approx = parseDownloadMessage(message);

              // 2) Start from any existing project data
              const existingProj =
                existingById.get(proj.id) || {
                  id: proj.id,
                  slug: proj.slug,
                  name: proj.name,
                  type: proj.type,
                  curseforgeUrl: proj.curseforgeUrl,
                  history: [],
                  logoUrl: null
                };

              existingProj.slug = proj.slug;
              existingProj.name = proj.name;
              existingProj.type = proj.type;
              existingProj.curseforgeUrl = proj.curseforgeUrl;

              // 3) Try to fetch logo from CurseForge HTML
              let logoUrl = existingProj.logoUrl || null;
              try {
                const html = await fetchPage(proj.curseforgeUrl);
                const extracted = extractLogoUrl(html);
                if (extracted) {
                  logoUrl = extracted;
                }
              } catch (e) {
                console.error(
                  `Failed to fetch logo for ${proj.name}:`,
                  e && e.message ? e.message : e
                );
              }
              existingProj.logoUrl = logoUrl;

              // 4) Append history entry
              const entry = {
                timestamp: now,
                downloadDisplay: message,
                downloadApprox: approx
              };

              existingProj.history.push(entry);
              if (existingProj.history.length > MAX_HISTORY) {
                existingProj.history = existingProj.history.slice(
                  existingProj.history.length - MAX_HISTORY
                );
              }

              updatedProjects.push(existingProj);
              console.log(
                `Recorded ${proj.name}: ${message} (approx ${approx}) at ${now}; logo: ${logoUrl || 'none'}`
              );
            }

            const finalData = {
              lastUpdated: now,
              projects: updatedProjects
            };

            fs.writeFileSync(
              'download-data.json',
              JSON.stringify(finalData, null, 2),
              'utf8'
            );

            console.log('Updated download-data.json');
          })().catch((err) => {
            console.error('Error updating download data:', err);
            process.exit(1);
          });
          EOF

      - name: Commit and push changes (if any)
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add download-data.json
            git commit -m "Update download counts & logos"
            git push
          else
            echo "No changes to commit.";
          fi
